=====================================
      POSTGRES TRAINING NOTES
=====================================
SITES:
https://blog.pgaddict.com/
https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server
commitfest.postgresql.org

MISC:
MariaDB is not opensource anymore - they have a new capability 'max...' so not opensource anymore
Everything is case-insensitive in postgres

BASICSL
Default port - 5432
Binaries - /usr/pgsql-<version>/bin 
Data - /var/lib/pgsql/<version>/data
Config files - in Data directory - postgresql.conf, postgresql.auto.conf, pg_hba.conf, pg_ident.conf
SQL client 'psql' - /usr/bin/psql -> /etc/alternatives/pgsql-psql
Postgres is extensible - can define new datatypes, functions, can use other languages for stored procs (like JS, Java...)

ARCHITECTURE:
http://raghavt.blogspot.in/2012/04/caching-in-postgresql.html
http://patshaughnessy.net/2016/1/22/is-your-postgres-query-starved-for-memory
http://rhaas.blogspot.in/2012/03/tuning-sharedbuffers-and-walbuffers.html

Datafiles (data folder) - uses regular filesystems
Memory - 
  Shared buffers (shared_buffers)--> set to upto 25% of system memory
  Page cache (not really set - it is just 'remaining os mem') --> recently read/written data - similar to db_block_buffers of Oracle
  Query memory
  Max connections (small memory used by connections)
  work_mem (dynamic at system, user, session level) --> for query-sorts etc, typically small like 4-16MB, 
      4MB good for most OLTP systems, large operations do multiple passes, and use temp files
      psql> alter user username set work_mem=128MB (to set at user level - applies  to all queries of the user)
  maintenance_work_mem (dynamic) - for maintenance operations like create index that needs sort data (could be set high like a GB)
  wal_buffers - 
  temp_buffers - 
  effective_cache_size (only a hint) - 

Temporary files - created as needed (similar to temp tablespace of Oracle)

Checkpoints and background writer:
      min_, max_wal_size
      checkpoint_timeout --> default 5 min, increase it to 30 min or so to avoid too much checkpoint write overhead
      checkpoint_completion_target
      bgrwriter_delay
      bgwriter_lru_maxpages
      bgwriter_lru_multiplier

There is no UNDO - only REDO
      Copies of modified data are written in the datafile itself - with a transaction ID. 
      When queried, latest comes up, and older ones are eventually cleared.

synchronous_commit:
off or on
Waits or not for confirmation of commits - so data may be lost - good for unimportant data (like discussions, comments etc)

CHECK STATUS OF THE SERVICE:
$ pg_ctl status -D /var/lib/pgsql/9.5/data
pg_ctl: server is running (PID: 3124)
/usr/pgsql-9.5/bin/postgres "-D" "/var/lib/pgsql/9.5/data"

STOP THE SERVICE:
$ pg_ctl stop -D /var/lib/pgsql/9.5/data
waiting for server to shut down.... done
server stopped

START THE SERVICE:
$ pg_ctl start -D /var/lib/pgsql/9.5/data

CAUTION:
You can run multiple instances to run on the same machine - however it is NOT ADVISABLE
--> One instance may hog up all CPU and the others are starved
--> 

TABLESPACES:
Not advisable as the 'restore' server should have the same folder structure??
Tablespaces are probably good when we have to host one DB on SSD, other on traditional disks etc.

BACKUPS:
CAUTION: Hot/physical backups are at instance level - so if instance becomes too large then backup/recovery becomes difficult
            For this, create VMs and distribute databases across multiple instances on those VMs

MANAGEMENT TOOLS:
$ pg_ctl
# /etc/init.d/postgres*
# service postgresql-9.5 initdb
      The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). 
      For other actions, please try to use systemctl.

CONNECTIVITY CONFIGURATION:
postgresql.conf
listen_addresses = 'localhost,127.0.0.1,<local actual hostname>'
#listen_addresses = '*'
#listen_addresses = 'localhost'         # what IP address(es) to listen on;

CLIENT AUTHENTICATION CONFIGURATION:
pg_hba.conf

INSTANCE CONFIGURATION:
postgresql.conf

DYNAMIC CONFIGURATION CHANGES:
ALTER SYSTEM SET max_connections=200;
- stored in postgresql.auto.conf
- overrides postgresql.conf
- always in dat dir, irrespective of where postgresql.conf is stored
Needs to restart/reload to take effect in the file :
--> some need restart of postgres itself
--> some work with pg_reload_conf (like work_mem)
      psql# alter system set work_mem=5000;
      psql#  select pg_reload_conf();
       pg_reload_conf
      ----------------
       t
      (1 row)
      
      psql# show work_mem;
       work_mem
      ----------
       5000kB
      (1 row)

OPTIMAL CONNECTIONS:
Optimal - twice the cores active connections (also factor in the connections by admins etc)
max_connections=100 is default - but assumes most connections idle if CPUs are less

SHARED_BUFFERS:
This is for data read from disk
Do not keep it very large as it is expensive to manage??
Postgres uses page caches...??

WORK_MEM:
For intermediate results of query

CREATE DATABASE:
create database <name> with owner=<username> template=template is_template=<yes|no> ... encoding, lc_collate, lc_type, tablespace...

postgres=# select * from pg_database;
  datname  | datdba | encoding | datcollate  |  datctype   | datistemplate | datallowconn | datconnlimit | datlastsysoid | datfrozenxid | datminmxid | dattablespace |
             datacl
-----------+--------+----------+-------------+-------------+---------------+--------------+--------------+---------------+--------------+------------+---------------+--
-----------------------------------
 template1 |     10 |        6 | en_US.UTF-8 | en_US.UTF-8 | t             | t            |           -1 |         13236 |         1740 |          1 |          1663 | {
=c/postgres,postgres=CTc/postgres}
 template0 |     10 |        6 | en_US.UTF-8 | en_US.UTF-8 | t             | f            |           -1 |         13236 |         1740 |          1 |          1663 | {
=c/postgres,postgres=CTc/postgres}
 postgres  |     10 |        6 | en_US.UTF-8 | en_US.UTF-8 | f             | t            |           -1 |         13236 |         1740 |          1 |          1663 |
(3 rows)

# \l
                                  List of databases
   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
-----------+----------+----------+-------------+-------------+-----------------------
 a b       | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
(4 rows)


- Can create a db with spaces within
# create database "a b";
# \c "a b"
# select quote_ident(datname) from pg_database;
 quote_ident
-------------
 template1
 template0
 postgres
 "a b"
(4 rows)


DATABASE INFORMATION
https://www.postgresql.org/docs/9.5/static/monitoring-stats.html

postgres=# \d pg_stat_database
          View "pg_catalog.pg_stat_database"
     Column     |           Type           | Modifiers
----------------+--------------------------+-----------
 datid          | oid                      |
 datname        | name                     |
 numbackends    | integer                  |
 xact_commit    | bigint                   |
 xact_rollback  | bigint                   |
 blks_read      | bigint                   |
 blks_hit       | bigint                   |
 tup_returned   | bigint                   |
 tup_fetched    | bigint                   |
 tup_inserted   | bigint                   |
 tup_updated    | bigint                   |
 tup_deleted    | bigint                   |
 conflicts      | bigint                   |
 temp_files     | bigint                   |
 temp_bytes     | bigint                   |
 deadlocks      | bigint                   |
 blk_read_time  | double precision         |
 blk_write_time | double precision         |
 stats_reset    | timestamp with time zone |

postgres=# select datid, datname, temp_files from pg_stat_database;
 datid |  datname  | temp_files
-------+-----------+------------
     1 | template1 |          0
 13236 | template0 |          0
 13241 | postgres  |          0
 16384 | a b       |          0
(4 rows)

MONITORING
Use the stats tables which provide snapshots of performance.
Graphana tool can collect it periodically by changing from check to metric - it will poll and store in its own 'influx' db

TABLESPACES
Use tablespaces only if really necessary - as they dont really provide any additional benefits.
(like different performance SAN and disks, SAN migrations, SAN filling up etc)

They need more meticulous restore where we need the same mount points etc.

It is a directory - not like Oracle's tablespace
Files are created similar to how they are created in the default 'data' directory
postgres=# create tablespace data2 location '/var/lib/pgsql/9.5/data2' [tablespace_option = ...] ;

tablespace_option can be performance options etc.

--> actually it creates a subdirectory as follows:
/var/lib/pgsql/9.5/data2/PG_9.5_201510051  --> PG_9.5... indicates it is a non-default tablespace

List tablespaces:
postgres=# \db
 data2      | postgres | /var/lib/pgsql/9.5/data2
 pg_default | postgres |
 pg_global  | postgres |

postgres=# select * from pg_tablespaces;

postgres=# create database mydb tablespace data2;
      CREATE DATABASE
--> creates db in a folder like /var/lib/pgsql/9.5/data2/PG_9.5_201510051/16386

postgres=# \c mydb
You are now connected to database "mydb" as user "postgres".

mydb=# create table emp (empid int primary key, name varchar(20));
      CREATE TABLE

mydb=# create table dept (deptid int primary key, name varchar(20)) tablespace data2;
      CREATE TABLE

--> the two tables get created in two different folders - emp in 'data' and dept in 'data2' folders db-id subfolders

SCHEMAS
mydb=# \c mydb
You are now connected to database "mydb" as user "postgres".

mydb=# create schema s1;
CREATE SCHEMA
mydb=# create schema s2 tablespace data2;
ERROR:  syntax error at or near "tablespace"
LINE 1: create schema s2 tablespace data2;
                         ^
mydb=#  create schema s2;
CREATE SCHEMA

mydb=> \dn
 public | postgres
 s1     | postgres
 s2     | postgres

mydb=> \dnS
 information_schema | postgres
 pg_catalog         | postgres
 pg_temp_1          | postgres
 pg_toast           | postgres
 pg_toast_temp_1    | postgres
 public             | postgres
 s1                 | postgres
 s2                 | postgres

mydb=# create table s1.e1 (id int, name varchar(10));
CREATE TABLE
mydb=# create table s2.e1 (id int, name varchar(10));
CREATE TABLE

mydb=# \dt s*.*
 s1     | e1   | table | postgres
 s2     | e1   | table | postgres

You cannot see the same tables from a different database:
mydb=# \c mydb2
You are now connected to database "mydb2" as user "postgres".
mydb2=# \dt s*.*
No matching relations found.
mydb2=# \c mydb
You are now connected to database "mydb" as user "postgres".
mydb=# \dt s*.*
 s1     | e1   | table | postgres
 s2     | e1   | table | postgres

USERS
postgres# \c mydb

mydb=# create user user1;
CREATE ROLE --> user is a ROLE with LOGIN privileges

mydb=# \du
 postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 user1 
 |                                                            | {}
 
mydb=# grant usage on schema s1 to user1;
GRANT

mydb=# grant all on s1.e1 to user1;
GRANT

mydb=# \z s1.e1
                                Access privileges
 Schema | Name | Type  |     Access privileges     | Column privileges | Policies
--------+------+-------+---------------------------+-------------------+----------
 s1     | e1   | table | postgres=arwdDxt/postgres+|                   |
        |      |       | user1=arwdDxt/postgres    |                   |
(1 row)

mydb=# set role user1;
SET

mydb=> \dt s*.*
 s1     | e1   | table | postgres
 s2     | e1   | table | postgres

mydb=> select * from s1.e1;
 id | name
----+------
(0 rows)

mydb=> select * from s2.e1;
ERROR:  permission denied for schema s2
LINE 1: select * from s2.e1;
